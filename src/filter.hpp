/*
 * Copyright (c) 2014 Zubax, zubax.com
 * Please refer to the file LICENSE for terms and conditions.
 * Author: Pavel Kirienko <pavel.kirienko@zubax.com>
 */

#pragma once

#include <ros/ros.h>
#include <ros/console.h>
#include <eigen3/Eigen/Eigen>
#include <cmath>
#include "mathematica.hpp"
#include "debug_publisher.hpp"
#include "linear_algebra.hpp"
#include "exception.hpp"
#include "state_vector_autogenerated.hpp"

namespace zubax_posekf
{

class Filter
{
    DebugPublisher debug_pub_;

    StateVector state_;
    Matrix<StateVector::Size, StateVector::Size> P_;
    Matrix<StateVector::Size, StateVector::Size> Q_;

    const Scalar MaxGyroDrift = 0.1;
    const Scalar MaxAccelDrift = 2.0;
    const Scalar MaxCovariance = 1e9;
    const Scalar MinVariance = 1e-9;

    Scalar state_timestamp_ = 0.0;
    bool initialized_ = false;

    static Vector3 constrainDrift(Vector3 vec, const Scalar limit, const char* name)
    {
        for (int i = 0; i < 3; i++)
        {
            if (!checkRangeAndConstrainSymmetric(vec[i], limit))
            {
                ROS_WARN_THROTTLE(1, "Drift is too high [%s]", name);
            }
        }
        return vec;
    }

    void normalizeAndCheck()
    {
        state_.normalize();

        state_.bw(constrainDrift(state_.bw(), MaxGyroDrift, "gyro"));

        state_.ba(constrainDrift(state_.ba(), MaxAccelDrift, "accel"));

        // P validation
        if (!validateAndFixCovarianceMatrix(P_, MaxCovariance, MinVariance))
        {
            ROS_ERROR_STREAM_THROTTLE(1, "Matrix P has been fixed\n" << P_);
        }

        debug_pub_.publish("x", state_.x);
        debug_pub_.publish("P", P_);
        debug_pub_.publish("Q", Q_);

        enforce("Non-finite states",
                std::isfinite(state_.x.sum()) &&
                std::isfinite(P_.sum()) &&
                std::isfinite(Q_.sum()));

        enforce("Invalid timestamp", std::isfinite(state_timestamp_) && (state_timestamp_ > 0.0));
    }

    template <int NumDims>
    void performMeasurementUpdate(const Vector<NumDims>& y,
                                  const Matrix<NumDims, NumDims>& R,
                                  const Matrix<NumDims, StateVector::Size>& H)
    {
        ROS_ASSERT(initialized_);

        const Matrix<NumDims, NumDims> R_sym = 0.5 * (R + R.transpose());  // Ensure that R is symmetric
        enforce("Measurement R", R.norm() > 0);

        Matrix<NumDims, NumDims> S_inv;
        {
            const Matrix<NumDims, NumDims> S = H * P_ * H.transpose() + R_sym;
            bool s_is_invertible = false;
            S.computeInverseWithCheck(S_inv, s_is_invertible);
            enforce("S is not invertible (numerical failure?)", s_is_invertible);
        }

        const auto K = static_cast<Matrix<StateVector::Size, NumDims> >(P_ * H.transpose() * S_inv);

        state_.x = state_.x + K * y;

        // Joseph form is used instead of the simplified form to improve numerical stability
        const Matrix<StateVector::Size, StateVector::Size> IKH = decltype(P_)::Identity() - K * H;
        P_ = IKH * P_ * IKH.transpose() + K * R_sym * K.transpose();

        normalizeAndCheck();
    }

public:
    Filter()
    {
        // Initial state - zero everything, null rotations
        state_.qwi(Quaternion(1, 0, 0, 0));
        state_.qvw(Quaternion(1, 0, 0, 0));

        // Initial P
        P_.setZero();
        P_ = StateVector::Pinitdiag().asDiagonal();

        // Initial Q
        // TODO: runtime Q estimation
        Q_ = StateVector::Qmindiag().asDiagonal();
    }

    bool isInitialized() const { return initialized_; }

    void initialize(Scalar timestamp, const Quaternion& orientation)
    {
        ROS_ASSERT(!initialized_);
        initialized_ = true;

        state_timestamp_ = timestamp;

        state_.qwi(orientation);

        normalizeAndCheck();

        ROS_INFO_STREAM("Initial P:\n" << P_);
        ROS_INFO_STREAM("Initial Q:\n" << Q_);
        ROS_INFO_STREAM("Initial x:\n" << state_.x);
    }

    void performTimeUpdate(Scalar timestamp)
    {
        ROS_ASSERT(initialized_);
        ROS_ASSERT(timestamp > 0);

        /*
         * Compute and check dt
         */
        const Scalar dt = timestamp - state_timestamp_;
        debug_pub_.publish("dt", dt);
        if (dt <= 0)
        {
            ROS_ERROR("Time update: Nonpositive dt [%f]", dt);
            return;
        }
        state_timestamp_ = timestamp;

        /*
         * Update the state vector and process covariance matrix
         */
        const auto F = state_.F(dt);

        state_.x = state_.f(dt);

        P_ = F * P_ * F.transpose() + Q_;

        normalizeAndCheck();

        // TODO: Commit point - add new X to the state history
    }

    void performAccelUpdate(const Vector3& accel, const Matrix3& cov)
    {
        const Vector3 y = accel - state_.hacc();
        performMeasurementUpdate(y, cov, state_.Hacc());
    }

    void performGyroUpdate(const Vector3& angvel, const Matrix3& cov)
    {
        const Vector3 y = angvel - state_.hgyro();
        performMeasurementUpdate(y, cov, state_.Hgyro());
    }

    void performGNSSPosUpdate(const Vector3& pos, const Matrix3& cov)
    {
        const Vector3 y = pos - state_.hgnsspos();
        performMeasurementUpdate(y, cov, state_.Hgnsspos());
    }

    void performGNSSVelUpdate(const Vector3& vel, const Matrix3& cov)
    {
        const Vector3 y = vel - state_.hgnssvel();
        performMeasurementUpdate(y, cov, state_.Hgnssvel());
    }

    void performVisPosUpdate(const Vector3& pos, const Matrix3& cov)
    {
        const Vector3 y = pos - state_.hvispos();
        performMeasurementUpdate(y, cov, state_.Hvispos());
    }

    void performVisAttUpdate(const Quaternion& z, const Matrix3& cov)
    {
        /*
         * Residual computation
         */
        const Quaternion h = state_.hvisatt();

        const Quaternion yq = z * h.inverse();  // Weiss 2012, eq. 3.45 ~ 3.46

        Vector<4> y;
        y[0] = yq.w();
        y[1] = yq.x();
        y[2] = yq.y();
        y[3] = yq.z();

        /*
         * Covariance transformation
         */
        const Matrix<4, 3> G = quaternionFromEulerJacobian(quaternionToEuler(z));
        const auto R = static_cast<Matrix<4, 4> >(G * cov * G.transpose());

        performMeasurementUpdate(y, R, state_.Hvisatt());

        debug_pub_.publish("visatt_R", R);
    }

    Scalar getTimestamp() const { return state_timestamp_; }

    std::pair<Quaternion, Matrix3> getOutputOrientation() const
    {
        const auto q = state_.qwi();
        const Matrix<3, 4> G = quaternionToEulerJacobian(q);
        const Matrix4 C = P_.block<4, 4>(StateVector::Idx::qwiw, StateVector::Idx::qwiw);
        const Matrix3 R = G * C * G.transpose();
        return {q, R};
    }

    std::pair<Vector3, Matrix3> getOutputAngularVelocity() const
    {
        return { state_.w(), P_.block<3, 3>(StateVector::Idx::ax, StateVector::Idx::ax) };
    }

    /// Gravity compensated
    std::pair<Vector3, Matrix3> getOutputAcceleration() const
    {
        return { state_.a(), P_.block<3, 3>(StateVector::Idx::wx, StateVector::Idx::wx) };
    }
};

}
